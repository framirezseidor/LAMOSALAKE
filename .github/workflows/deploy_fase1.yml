# ===============================================================
# üöÄ WORKFLOW: Deploy Snowflake on Merge
# ---------------------------------------------------------------
# Este workflow automatiza el despliegue de objetos SQL en Snowflake
# cada vez que un Pull Request hacia la rama "main" es cerrado y mergeado.
# 
# FUNCIONALIDAD:
#   - Detecta los archivos .SQL modificados en el PR
#   - Sustituye prefijos de ambiente (ej. SQ1_ ‚Üí SP1_)
#   - Ejecuta los scripts en orden l√≥gico (TABLES ‚Üí VIEWS ‚Üí FUNCTIONS ‚Üí SP ‚Üí TASKS ‚Üí MISC)
#   - Detiene la ejecuci√≥n si alg√∫n script falla
#   - Crea un tag de despliegue opcional en el repositorio
# ===============================================================

name: Deploy Snowflake on Merge

on:
  pull_request:
    types:
      - closed
    branches:
      - main

jobs:
  deploy:
    # ------------------------------------------------------------
    # Este job solo se ejecuta si el Pull Request fue mergeado a main
    # ------------------------------------------------------------
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    # ------------------------------------------------------------
    # Permisos necesarios para crear tags o modificar contenido del repo
    # ------------------------------------------------------------
    permissions:
      contents: write

    steps:
      # ==========================================================
      # 1Ô∏è‚É£ CHECKOUT DEL REPOSITORIO
      # ----------------------------------------------------------
      # Clona el repositorio completo (fetch-depth=0)
      # para garantizar acceso a todo el historial del PR.
      # ==========================================================
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ==========================================================
      # 2Ô∏è‚É£ DETECCI√ìN DE ARCHIVOS SQL MODIFICADOS
      # ----------------------------------------------------------
      # Usa la API de GitHub para listar los archivos del PR
      # y filtra solo aquellos con extensi√≥n .sql (sin importar may√∫sculas).
      # ==========================================================
      - name: Obtener archivos .sql modificados
        id: get-changes
        run: |
          echo "üì• Consultando archivos del PR #${{ github.event.pull_request.number }}..."
          curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github.v3+json" \
               "${{ github.api_url }}/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files" \
            | jq -r '.[].filename' | grep -i '\.sql$' > changed_files.txt || true

          echo "üìÇ Archivos SQL detectados:"
          cat changed_files.txt || echo "‚ö†Ô∏è No se detectaron archivos SQL modificados."

      # ==========================================================
      # 3Ô∏è‚É£ VALIDACI√ìN DE CAMBIOS
      # ----------------------------------------------------------
      # Revisa si el archivo changed_files.txt est√° vac√≠o.
      # Si no hay scripts SQL, el workflow finaliza sin error.
      # ==========================================================
      - name: Verificar si hay scripts para ejecutar
        id: check
        run: |
          if [ ! -s changed_files.txt ]; then
            echo "no_changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ No se detectaron scripts SQL para desplegar."
          else
            echo "no_changes=false" >> $GITHUB_OUTPUT
            echo "üöÄ Se detectaron scripts SQL, procederemos al deploy."
          fi

      # ==========================================================
      # 4Ô∏è‚É£ CONFIGURACI√ìN DE CONEXI√ìN SNOWFLAKE
      # ----------------------------------------------------------
      # Crea el archivo .snowflake/config.toml con las credenciales
      # almacenadas en los GitHub Secrets.
      # ==========================================================
      - name: Crear archivo de conexi√≥n Snowflake
        if: steps.check.outputs.no_changes == 'false'
        run: |
          mkdir -p .snowflake
          cat <<EOF > .snowflake/config.toml
          default_connection_name = "connectionSnowflake"
          [connections]
          [connections.connectionSnowflake]
          account = "${{ secrets.SNOWFLAKE_ACCOUNT }}"
          user = "${{ secrets.SNOWFLAKE_USER }}"
          password = "${{ secrets.SNOWFLAKE_PASSWORD }}"
          role = "${{ secrets.SNOWFLAKE_ROLE }}"
          warehouse = "${{ secrets.SNOWFLAKE_WAREHOUSE }}"
          database = "${{ secrets.SNOWFLAKE_DATABASE }}"
          schema = "${{ secrets.SNOWFLAKE_SCHEMA }}"
          EOF
          
          echo "‚úÖ Archivo de configuraci√≥n creado correctamente."

      - name: Verificar archivo de configuraci√≥n
        if: steps.check.outputs.no_changes == 'false'
        run: ls -la .snowflake && cat .snowflake/config.toml

      # ==========================================================
      # 5Ô∏è‚É£ INSTALACI√ìN Y PRUEBA DEL CLIENTE SNOWFLAKE CLI
      # ----------------------------------------------------------
      # Instala la versi√≥n m√°s reciente del CLI y prueba la conexi√≥n.
      # ==========================================================
      - name: Instalar Snowflake CLI
        if: steps.check.outputs.no_changes == 'false'
        uses: Snowflake-Labs/snowflake-cli-action@v1.5
        with:
          cli-version: "latest"
          default-config-file-path: ".snowflake/config.toml"

      - name: Verificar conexi√≥n a Snowflake
        if: steps.check.outputs.no_changes == 'false'
        run: |
          snow --version
          snow connection test
          echo "‚úÖ Conexi√≥n verificada correctamente."

      # ==========================================================
      # 6Ô∏è‚É£ REEMPLAZO DE PREFIJOS DE AMBIENTE
      # ----------------------------------------------------------
      # Cambia el prefijo SQ1_ (DEV) por SP1_ (PROD)
      # antes de ejecutar los scripts.
      # ==========================================================
      - name: Reemplazar prefijos para producci√≥n
        if: steps.check.outputs.no_changes == 'false'
        env:
          ORIGIN_PREFIX: "SQ1_"
          PROD_PREFIX: "SP1_"
        run: |
          echo "üîÑ Reemplazando prefijos de ${ORIGIN_PREFIX} a ${PROD_PREFIX}..."
          while read -r file; do
            if [[ -f "$file" ]]; then
              sed -i -E "s/\b${ORIGIN_PREFIX}/${PROD_PREFIX}/g" "$file"
              echo "‚úîÔ∏è  Prefijo reemplazado en: $file"
            fi
          done < changed_files.txt

      # ==========================================================
      # 7Ô∏è‚É£ EJECUCI√ìN ORDENADA DE SCRIPTS
      # ----------------------------------------------------------
      # Ejecuta los scripts modificados en orden l√≥gico por tipo:
      # TABLES ‚Üí VIEWS ‚Üí FUNCTIONS ‚Üí SP ‚Üí TASKS ‚Üí MISC
      # Si un script falla, el workflow se detiene con error.
      # ==========================================================
      - name: Ejecutar scripts SQL modificados (por tipo de objeto)
        if: steps.check.outputs.no_changes == 'false'
        run: |
          mkdir -p deploy_metadata
          LOG_FILE="deploy_metadata/deploy_log_$(date +'%Y%m%d-%H%M%S').txt"

          echo "üìÖ Fecha de ejecuci√≥n: $(date)" > $LOG_FILE
          echo "üîΩ Orden de ejecuci√≥n: TABLES ‚Üí VIEWS ‚Üí FUNCTIONS ‚Üí SP ‚Üí TASKS ‚Üí MISC" >> $LOG_FILE
          echo "---------------------------------------------------------------" >> $LOG_FILE

          ORDER=("TABLES" "TABLAS" "VIEWS" "VISTAS" "FUNCTIONS" "SP" "PROCEDURES" "TASKS")
          touch executed_files.txt

          for DIR in "${ORDER[@]}"; do
            echo "‚ñ∂Ô∏è Buscando scripts en carpeta $DIR..." | tee -a $LOG_FILE
            grep -i "/${DIR}/" changed_files.txt | while read -r file; do
              if [[ -f "$file" ]]; then
                echo "‚öôÔ∏è Ejecutando $file..." | tee -a $LOG_FILE
                if snow sql -f "$file" >> $LOG_FILE 2>&1; then
                  echo "‚úÖ √âxito: $file" | tee -a $LOG_FILE
                  echo "$file" >> executed_files.txt
                else
                  echo "‚ùå Error al ejecutar $file. Abortando despliegue." | tee -a $LOG_FILE
                  exit 1
                fi
              fi
            done
          done

          echo "‚ñ∂Ô∏è Buscando scripts fuera de categor√≠as conocidas..." | tee -a $LOG_FILE
          grep -v -F -f executed_files.txt changed_files.txt > misc_files.txt || true

          if [ -s misc_files.txt ]; then
            echo "üìÇ Archivos detectados como MISC:" | tee -a $LOG_FILE
            cat misc_files.txt | tee -a $LOG_FILE
            while read -r file; do
              if [[ -f "$file" ]]; then
                echo "‚öôÔ∏è Ejecutando $file (MISC)..." | tee -a $LOG_FILE
                if snow sql -f "$file" >> $LOG_FILE 2>&1; then
                  echo "‚úÖ √âxito: $file" | tee -a $LOG_FILE
                else
                  echo "‚ùå Error al ejecutar $file (MISC). Abortando despliegue." | tee -a $LOG_FILE
                  exit 1
                fi
              fi
            done < misc_files.txt
          else
            echo "‚úÖ No se detectaron archivos fuera de las categor√≠as principales." | tee -a $LOG_FILE
          fi

          echo "---------------------------------------------------------------" >> $LOG_FILE
          echo "‚úÖ Despliegue completado: $(date)" >> $LOG_FILE

      # ==========================================================
      # 8Ô∏è‚É£ CREACI√ìN DE TAG DE DESPLIEGUE (OPCIONAL)
      # ----------------------------------------------------------
      # Crea un tag de versi√≥n con timestamp para identificar
      # el commit desplegado. Requiere permisos de escritura.
      # ==========================================================
      - name: Crear tag de despliegue
        if: steps.check.outputs.no_changes == 'false'
        run: |
          NEW_TAG="deploy-$(date +'%Y%m%d-%H%M%S')"
          git tag $NEW_TAG
          git push origin $NEW_TAG
          echo "üè∑ Nuevo tag de despliegue creado: $NEW_TAG"
