name: Deploy Snowflake on Merge

on:
  pull_request:
    types:
      - closed
    branches:
      - main

jobs:
  deploy:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      # 1Ô∏è‚É£ Checkout del repositorio
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2Ô∏è‚É£ Obtener archivos cambiados del PR usando la API de GitHub
      - name: Obtener archivos .sql modificados
        id: get-changes
        run: |
          echo "Consultando archivos del PR #${{ github.event.pull_request.number }}..."
          curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github.v3+json" \
               "${{ github.api_url }}/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files" \
            | jq -r '.[].filename' | grep -i '\.sql$' > changed_files.txt || true

          echo "Archivos detectados:"
          cat changed_files.txt || echo "‚ö†Ô∏è No hay archivos SQL modificados."

      # 3Ô∏è‚É£ Validar si hay cambios antes de continuar
      - name: Verificar si hay scripts para ejecutar
        id: check
        run: |
          if [ ! -s changed_files.txt ]; then
            echo "no_changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ No se detectaron scripts SQL para desplegar."
          else
            echo "no_changes=false" >> $GITHUB_OUTPUT
            echo "üöÄ Se detectaron scripts SQL, procederemos al deploy."
          fi

      # 4Ô∏è‚É£ (Opcional) Reemplazar prefijos en los scripts
      - name: Reemplazar prefijos para producci√≥n
        if: steps.check.outputs.no_changes == 'false'
        env:
          ORIGIN_PREFIX: "SQ1_"
          PROD_PREFIX: "SP1_"
        run: |
          while read -r file; do
            if [[ -f "$file" ]]; then
              echo "Cambiando prefijo en: $file"
              sed -i -E "s/\b${ORIGIN_PREFIX}/${PROD_PREFIX}/g" "$file"
            fi
          done < changed_files.txt

      # 5Ô∏è‚É£ Ejecutar los scripts SQL en Snowflake
      - name: Ejecutar scripts SQL modificados
        if: steps.check.outputs.no_changes == 'false'
        run: |
          while read -r file; do
            if [[ -f "$file" ]]; then
              echo "Ejecutando $file..."
              snow sql -f "$file"
            else
              echo "‚ö†Ô∏è El archivo $file no existe en el repo."
            fi
          done < changed_files.txt

      # 6Ô∏è‚É£ Crear tag de despliegue (opcional)
      - name: Crear tag de despliegue
        if: steps.check.outputs.no_changes == 'false'
        run: |
          NEW_TAG="deploy-$(date +'%Y%m%d-%H%M%S')"
          git tag $NEW_TAG
          git push origin $NEW_TAG
          echo "üè∑ Nuevo tag de despliegue creado: $NEW_TAG"


# name: 01 - Detectar cambios y guardar en repo

# on:
#   pull_request:
#     types: [opened, synchronize, reopened]

# jobs:
#   detect_changes:
#     runs-on: ubuntu-latest

#     steps:
#       - name: Checkout repo
#         uses: actions/checkout@v4
#         with:
#           fetch-depth: 0

#       - name: Detectar archivos modificados en MODELOS
#         id: changed
#         uses: tj-actions/changed-files@v44
#         with:
#           base_sha: ${{ github.event.pull_request.base.sha }}
#           sha: ${{ github.event.pull_request.head.sha }}
#           path: MODELOS

#       - name: Mostrar archivos detectados
#         run: |
#           echo "Archivos modificados:"
#           echo "${{ steps.changed.outputs.all_changed_files }}"

#       - name: Guardar lista en archivo
#         run: |
#           mkdir -p deploy_metadata
#           echo "${{ steps.changed.outputs.all_changed_files }}" | tr ' ' '\n' > deploy_metadata/changed_files.txt
#           cat deploy_metadata/changed_files.txt

#       - name: Configurar Git para commit
#         run: |
#           git config user.name "github-actions[bot]"
#           git config user.email "github-actions[bot]@users.noreply.github.com"

#       - name: Guardar lista de cambios en rama deploy-metadata
#         run: |
#           # Nos aseguramos de no ensuciar main
#           git fetch origin deploy-metadata || true
#           git checkout deploy-metadata || git checkout -b deploy-metadata

#           # Si no existe la carpeta, la creamos (por si es la primera vez)
#           mkdir -p deploy_metadata

#           git add deploy_metadata/changed_files.txt
#           git commit -m "Actualizar lista de archivos cambiados para PR #${{ github.event.pull_request.number }}" || echo "No hay cambios para commitear"
#           git push origin deploy-metadata




# name: Deploy fase 1

# on:
#   pull_request:
#     branches:
#       - main
#     types: [opened, synchronize, reopened]

# jobs:
#   validate-changes:
#     runs-on: ubuntu-latest

#     steps:
#       - name: Checkout PR code
#         uses: actions/checkout@v3
#         with:
#           fetch-depth: 0

#       - name: Obtener lista de archivos modificados en MODELOS/
#         id: cambios
#         run: |
#           git fetch origin main
#           git diff --name-only origin/main...HEAD -- MODELOS/ > changed_files.txt
#           echo "Archivos modificados:"
#           cat changed_files.txt || true

#           if [ -s changed_files.txt ]; then
#             echo "modelos_changed=true" >> $GITHUB_OUTPUT
#           else
#             echo "modelos_changed=false" >> $GITHUB_OUTPUT
#           fi

#       - name: Subir lista de archivos modificados como artefacto
#         uses: actions/upload-artifact@v4
#         with:
#           name: modelos-pr-changes
#           path: ./changed_files.txt
#           if-no-files-found: warn
#           compression-level: 6
#           overwrite: true
#           include-hidden-files: false


#       - name: Validar scripts (ejemplo)
#         if: steps.cambios.outputs.modelos_changed == 'true'
#         run: |
#           echo "‚úÖ Validando sintaxis b√°sica..."
#           while IFS= read -r file; do
#             echo "Validando $file"
#             # Aqu√≠ podr√≠as usar: snow sql --dry-run -f "$file"
#             # o validaciones personalizadas con grep/sed
#           done < changed_files.txt

